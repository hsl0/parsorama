(()=>{"use strict";var t={d:(r,e)=>{for(var s in e)t.o(e,s)&&!t.o(r,s)&&Object.defineProperty(r,s,{enumerable:!0,get:e[s]})},o:(t,r)=>Object.prototype.hasOwnProperty.call(t,r),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},r={};t.r(r),t.d(r,{Any:()=>h,Content:()=>f,Form:()=>s,FormExp:()=>e,Max:()=>u,Min:()=>p,OneMore:()=>i,Optional:()=>a,Quantitier:()=>n,Repeat:()=>o,Syntax:()=>l,ZeroMore:()=>c,ZeroOne:()=>a});const e={parse(t,r){if(t instanceof o)return t.parse(r);if(t instanceof h)return t.parse(r);if(t instanceof Object&&"parse"in t)return t.parse(r);if("string"==typeof t){const e=new RegExp(`^${t}`),s=r.match(e);return s?s[0]:null}throw new TypeError(`Part's type "${typeof t}" is wrong type`)}};class s extends Array{constructor(...t){Array.isArray(t[0])&&1===t.length&&(t=t[0]),super(),super.push(...t)}parse(t){if("string"!=typeof t)throw new TypeError("Content is not string");const r=new f;for(const s of this){const n=e.parse(s,t);r.push(n),n&&(t=t.slice(n.toString().length))}return r}static new(t,...r){const e=[];for(let s=0;s<t.raw.length;s++)e.push(t.raw[s]),s in r&&e.push(r[s]);return new this(e)}}let n;!function(t){t[t.GREEDY=0]="GREEDY",t[t.LAZY=1]="LAZY"}(n||(n={}));class o{constructor(t,r,e,s){this.content=t,this.min=r||0,this.max=e||r,this.quantitier=s}parse(t,r=0){if(r>=this.max)return t;if(r<this.min)throw new TypeError("Given content doesn't match with format");const s=e.parse(this.content,t);if(null==s)return null;if(t=t.slice(s.toString().length),"string"==typeof s)return s+this.parse(t,++r);{const e=this.parse(t,++r);return e?new f(s,...e):new f(s)}}}class a extends o{constructor(t,r){super(t,0,1,r)}}class i extends o{constructor(t,r){super(t,1,1/0,r)}}class c extends o{constructor(t,r){super(t,0,1/0,r)}}class p extends o{constructor(t,r,e){super(t,r,1/0,e)}}class u extends o{constructor(t,r,e){super(t,0,r,e)}}class h extends Set{constructor(...t){try{super(1===t.length&&t[0][Symbol.iterator]?t[0]:t)}catch(r){if(r instanceof TypeError&&"Constructor Set requires 'new'"===r.message)return Reflect.construct(Set,[1===t.length&&t[0][Symbol.iterator]?t[0]:t],new.target)}}parse(t){for(const r of this){const s=e.parse(r,t);if(s)return s}throw new TypeError("Given content doesn't match with format")}}class f extends Array{constructor(...t){super(),Array.isArray(t[0])&&1===t.length&&t[0],super.push(...t)}toString(){return this.join("")}static form(...t){return class extends(this){static format=t[0].raw?s.new(...t):new s(...t);static parse(t){return this.format instanceof s||(this.format=new s(this.format)),this.parseTree(this.format.parse(t))}}}}class l{static parseTree(t){return t}static parse(t){return this.format instanceof s||(this.format=new s(this.format)),this.parseTree(this.format.parse(t))}}window.parsorama=r})();
//# sourceMappingURL=web.js.map