{"version":3,"sources":["../src/parsorama.ts"],"names":["FormExp","parse","part","content","Repeat","Any","Object","regex","RegExp","matches","match","TypeError","Form","Array","constructor","arr","isArray","length","push","tree","Content","slice","toString","new","str","exp","index","raw","Quantitier","form","min","max","quantitier","count","next","Optional","ZeroOne","OneMore","Infinity","ZeroMore","Min","Max","Set","forms","Symbol","iterator","err","message","Reflect","construct","target","args","join","format","parseTree","Syntax"],"mappings":"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","sourcesContent":["export type FormExp = Form | RegExp | string | Repeat | Any | SyntaxConstructor;\r\nexport const FormExp = {\r\n    parse(part: FormExp, content: string): string|Syntax|null {\r\n        if(part instanceof Repeat) return part.parse(content);\r\n        \r\n        if(part instanceof Any) return part.parse(content);\r\n        \r\n        if(part instanceof Object && 'parse' in part) return part.parse(content);\r\n        \r\n        if(typeof part === 'string') {\r\n            const regex = new RegExp(`^${part}`);\r\n            const matches: string[] | null = content.match(regex);\r\n\r\n            if(matches) return matches[0];\r\n            else return null;\r\n        }\r\n\r\n        throw new TypeError(`Part's type \"${typeof part}\" is wrong type`);\r\n    }\r\n}\r\n\r\nexport class Form extends Array <FormExp> {\r\n    constructor(...arr: FormExp[] | [FormExp[]]) {\r\n        if (Array.isArray(arr[0]) && arr.length === 1) arr = arr[0];\r\n\r\n        super();\r\n        super.push(...arr as FormExp[]);\r\n    }\r\n\r\n    parse(content: string): Content {\r\n        if(typeof content !== 'string') throw new TypeError('Content is not string');\r\n\r\n        const tree = new Content();\r\n\r\n        for(const part of this) {\r\n            const match = FormExp.parse(part, content)\r\n            tree.push(match);\r\n            if(match) content = content.slice(match.toString().length);\r\n        }\r\n\r\n        return tree;\r\n    }\r\n\r\n    static new(str: TemplateStringsArray, ...exp: FormExp[]): Form {\r\n        const arr = [];\r\n\r\n        for (let index = 0; index < str.raw.length; index++) {\r\n            arr.push(str.raw[index]);\r\n            if (index in exp) arr.push(exp[index]);\r\n        }\r\n\r\n        return new this(arr);\r\n    }\r\n}\r\n\r\nexport enum Quantitier {\r\n    GREEDY,\r\n    LAZY\r\n}\r\n\r\nexport class Repeat {\r\n    min: number;\r\n    max: number;\r\n    content: FormExp;\r\n    quantitier: Quantitier;\r\n\r\n    constructor(form: FormExp, min: number, max: number, quantitier: Quantitier) {\r\n        this.content = form;\r\n        this.min = min || 0;\r\n        this.max = max || min;\r\n        this.quantitier = quantitier;\r\n    }\r\n    \r\n    parse(content: string, count = 0): string|Content|null {\r\n        if(count >= this.max) return content;\r\n        \r\n        if(count < this.min) throw new TypeError(\"Given content doesn't match with format\");\r\n        \r\n        const match: Syntax | string | null = FormExp.parse(this.content, content);\r\n\r\n        if(match == null) return null;\r\n\r\n        content = content.slice(match.toString().length);\r\n        \r\n        if(typeof match === 'string') return match + this.parse(content, ++count);\r\n        else {\r\n            const next = this.parse(content, ++count);\r\n            if(next) return new Content(match, ...next);\r\n            else return new Content(match);\r\n        }\r\n    }\r\n}\r\nexport class Optional extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 0, 1, quantitier);\r\n    }\r\n}\r\nexport {\r\n    Optional as ZeroOne\r\n};\r\nexport class OneMore extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 1, Infinity, quantitier);\r\n    }\r\n}\r\nexport class ZeroMore extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 0, Infinity, quantitier);\r\n    }\r\n}\r\nexport class Min extends Repeat {\r\n    constructor(form: FormExp, min: number, quantitier: Quantitier) {\r\n        super(form, min, Infinity, quantitier);\r\n    }\r\n}\r\nexport class Max extends Repeat {\r\n    constructor(form: FormExp, max: number, quantitier: Quantitier) {\r\n        super(form, 0, max, quantitier);\r\n    }\r\n}\r\n\r\nexport class Any extends Set {\r\n    constructor(...forms: FormExp[] | [Iterable<FormExp>]) {\r\n        try {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore Iterable<FormExp> can't be assigned to readonly any[]\r\n            super((forms.length === 1 && forms[0][Symbol.iterator]) ? forms[0] : forms);\r\n        } catch (err) {\r\n            if (err instanceof TypeError && err.message === \"Constructor Set requires 'new'\") {\r\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n                //@ts-ignore Element implicitly has an 'any' type because expression of type 'symbol' can't be used to index type 'FormExp | Iterable<FormExp>'.\r\n                return Reflect.construct(Set, [(forms.length === 1 && forms[0][Symbol.iterator]) ? forms[0] : forms], new.target);\r\n            }\r\n        }\r\n    }\r\n    \r\n    parse(content: string): Syntax {\r\n        for(const form of this) {\r\n            const match = FormExp.parse(form, content);\r\n            if(match) return match;\r\n        }\r\n        throw new TypeError(\"Given content doesn't match with format\")\r\n    }\r\n}\r\n\r\nexport class Content extends Array {\r\n    constructor(...args: unknown[]) {\r\n        super();\r\n        if (Array.isArray(args[0]) && args.length === 1) args === args[0];\r\n        super.push(...args);\r\n    }\r\n\r\n    toString(): string {\r\n        return this.join('');\r\n    }\r\n\r\n    static form(...args: [TemplateStringsArray, ...FormExp[]] | FormExp[]): SyntaxConstructor {\r\n        return class extends this {\r\n            static format = (args[0] as TemplateStringsArray).raw ? Form.new(...args as[TemplateStringsArray, ...FormExp[]]) : new Form(...args as FormExp[]);\r\n\r\n            static parseTree: (tree: Content) => Syntax;\r\n            static parse(content: string): Syntax {\r\n                if (!(this.format instanceof Form)) this.format = new Form(this.format);\r\n                return this.parseTree((this.format as Form).parse(content));\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\nexport abstract class Syntax {\r\n    static format: FormExp;\r\n\r\n    static parseTree(tree: Content): Syntax {\r\n        return tree;\r\n    }\r\n\r\n    static parse(content: string): Syntax {\r\n        if(!(this.format instanceof Form)) this.format = new Form(this.format);\r\n        return this.parseTree((this.format as Form).parse(content));\r\n    }\r\n}\r\ninterface SyntaxConstructor {\r\n    new (...args: unknown[]): Syntax;\r\n    format: FormExp;\r\n    parseTree(tree: Content): Syntax;\r\n    parse(content: string): Syntax;\r\n}\r\n\r\n// eslint-disable-next-line no-debugger\r\ndebugger;\r\n"],"file":"parsorama.js"}