{"version":3,"sources":["webpack://parsorama/webpack/bootstrap","webpack://parsorama/webpack/runtime/define property getters","webpack://parsorama/webpack/runtime/hasOwnProperty shorthand","webpack://parsorama/webpack/runtime/make namespace object","webpack://parsorama/./src/parsorama.ts","webpack://parsorama/./src/web.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","FormExp","parse","part","content","Repeat","Any","regex","RegExp","matches","match","TypeError","Form","Array","constructor","arr","isArray","length","super","push","tree","Content","this","slice","toString","str","exp","index","raw","Quantitier","form","min","max","quantitier","count","next","Optional","OneMore","Infinity","ZeroMore","Min","Max","Set","forms","iterator","err","message","Reflect","construct","args","join","new","format","parseTree","Syntax","window","parsorama"],"mappings":"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","file":"web.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type FormExp = Form | RegExp | string | Repeat | Any | SyntaxConstructor;\r\nexport const FormExp = {\r\n    parse(part: FormExp, content: string): string|Syntax|null {\r\n        if(part instanceof Repeat) return part.parse(content);\r\n        \r\n        if(part instanceof Any) return part.parse(content);\r\n        \r\n        if(part instanceof Object && 'parse' in part) return part.parse(content);\r\n        \r\n        if(typeof part === 'string') {\r\n            const regex = new RegExp(`^${part}`);\r\n            const matches: string[] | null = content.match(regex);\r\n\r\n            if(matches) return matches[0];\r\n            else return null;\r\n        }\r\n\r\n        throw new TypeError(`Part's type \"${typeof part}\" is wrong type`);\r\n    }\r\n}\r\n\r\nexport class Form extends Array <FormExp> {\r\n    constructor(...arr: FormExp[] | [FormExp[]]) {\r\n        if (Array.isArray(arr[0]) && arr.length === 1) arr = arr[0];\r\n\r\n        super();\r\n        super.push(...arr as FormExp[]);\r\n    }\r\n\r\n    parse(content: string): Content {\r\n        if(typeof content !== 'string') throw new TypeError('Content is not string');\r\n\r\n        const tree = new Content();\r\n\r\n        for(const part of this) {\r\n            const match = FormExp.parse(part, content)\r\n            tree.push(match);\r\n            if(match) content = content.slice(match.toString().length);\r\n        }\r\n\r\n        return tree;\r\n    }\r\n\r\n    static new(str: TemplateStringsArray, ...exp: FormExp[]): Form {\r\n        const arr = [];\r\n\r\n        for (let index = 0; index < str.raw.length; index++) {\r\n            arr.push(str.raw[index]);\r\n            if (index in exp) arr.push(exp[index]);\r\n        }\r\n\r\n        return new this(arr);\r\n    }\r\n}\r\n\r\nexport enum Quantitier {\r\n    GREEDY,\r\n    LAZY\r\n}\r\n\r\nexport class Repeat {\r\n    min: number;\r\n    max: number;\r\n    content: FormExp;\r\n    quantitier: Quantitier;\r\n\r\n    constructor(form: FormExp, min: number, max: number, quantitier: Quantitier) {\r\n        this.content = form;\r\n        this.min = min || 0;\r\n        this.max = max || min;\r\n        this.quantitier = quantitier;\r\n    }\r\n    \r\n    parse(content: string, count = 0): string|Content|null {\r\n        if(count >= this.max) return content;\r\n        \r\n        if(count < this.min) throw new TypeError(\"Given content doesn't match with format\");\r\n        \r\n        const match: Syntax | string | null = FormExp.parse(this.content, content);\r\n\r\n        if(match == null) return null;\r\n\r\n        content = content.slice(match.toString().length);\r\n        \r\n        if(typeof match === 'string') return match + this.parse(content, ++count);\r\n        else {\r\n            const next = this.parse(content, ++count);\r\n            if(next) return new Content(match, ...next);\r\n            else return new Content(match);\r\n        }\r\n    }\r\n}\r\nexport class Optional extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 0, 1, quantitier);\r\n    }\r\n}\r\nexport {\r\n    Optional as ZeroOne\r\n};\r\nexport class OneMore extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 1, Infinity, quantitier);\r\n    }\r\n}\r\nexport class ZeroMore extends Repeat {\r\n    constructor(form: FormExp, quantitier: Quantitier) {\r\n        super(form, 0, Infinity, quantitier);\r\n    }\r\n}\r\nexport class Min extends Repeat {\r\n    constructor(form: FormExp, min: number, quantitier: Quantitier) {\r\n        super(form, min, Infinity, quantitier);\r\n    }\r\n}\r\nexport class Max extends Repeat {\r\n    constructor(form: FormExp, max: number, quantitier: Quantitier) {\r\n        super(form, 0, max, quantitier);\r\n    }\r\n}\r\n\r\nexport class Any extends Set {\r\n    constructor(...forms: FormExp[] | [Iterable<FormExp>]) {\r\n        try {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore Iterable<FormExp> can't be assigned to readonly any[]\r\n            super((forms.length === 1 && forms[0][Symbol.iterator]) ? forms[0] : forms);\r\n        } catch (err) {\r\n            if (err instanceof TypeError && err.message === \"Constructor Set requires 'new'\") {\r\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n                //@ts-ignore Element implicitly has an 'any' type because expression of type 'symbol' can't be used to index type 'FormExp | Iterable<FormExp>'.\r\n                return Reflect.construct(Set, [(forms.length === 1 && forms[0][Symbol.iterator]) ? forms[0] : forms], new.target);\r\n            }\r\n        }\r\n    }\r\n    \r\n    parse(content: string): Syntax {\r\n        for(const form of this) {\r\n            const match = FormExp.parse(form, content);\r\n            if(match) return match;\r\n        }\r\n        throw new TypeError(\"Given content doesn't match with format\")\r\n    }\r\n}\r\n\r\nexport class Content extends Array {\r\n    constructor(...args: unknown[]) {\r\n        super();\r\n        if (Array.isArray(args[0]) && args.length === 1) args === args[0];\r\n        super.push(...args);\r\n    }\r\n\r\n    toString(): string {\r\n        return this.join('');\r\n    }\r\n\r\n    static form(...args: [TemplateStringsArray, ...FormExp[]] | FormExp[]): SyntaxConstructor {\r\n        return class extends this {\r\n            static format = (args[0] as TemplateStringsArray).raw ? Form.new(...args as[TemplateStringsArray, ...FormExp[]]) : new Form(...args as FormExp[]);\r\n\r\n            static parseTree: (tree: Content) => Syntax;\r\n            static parse(content: string): Syntax {\r\n                if (!(this.format instanceof Form)) this.format = new Form(this.format);\r\n                return this.parseTree((this.format as Form).parse(content));\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\nexport abstract class Syntax {\r\n    static format: FormExp;\r\n\r\n    static parseTree(tree: Content): Syntax {\r\n        return tree;\r\n    }\r\n\r\n    static parse(content: string): Syntax {\r\n        if(!(this.format instanceof Form)) this.format = new Form(this.format);\r\n        return this.parseTree((this.format as Form).parse(content));\r\n    }\r\n}\r\ninterface SyntaxConstructor {\r\n    new (...args: unknown[]): Syntax;\r\n    format: FormExp;\r\n    parseTree(tree: Content): Syntax;\r\n    parse(content: string): Syntax;\r\n}\r\n\r\n// eslint-disable-next-line no-debugger\r\ndebugger;\r\n","import * as parsorama from \"./parsorama.ts\";\r\nwindow.parsorama = parsorama;"],"sourceRoot":""}